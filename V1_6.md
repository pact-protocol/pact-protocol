# PACT v1.6

PACT v1.6 builds on v1.5 by adding settlement lifecycle management and idempotency, preparing for external payment rail integration without changing core protocol semantics.

---

## Summary

v1.6 introduces:

1. **Settlement Lifecycle API**: Structured prepare/commit/abort workflow for settlement operations
2. **Idempotency**: Safe retries via deterministic handle IDs and idempotent operations
3. **Backward Compatibility**: All existing settlement methods (lock/pay/release/slashBond) remain unchanged

These features enable reliable settlement operations and prepare for integration with external payment rails while maintaining full backward compatibility with v1.5.

---

## Settlement Lifecycle (v1.6.1+)

v1.6.1 introduces a formal lifecycle API for settlement operations, enabling idempotent settlement workflows and preparing for external payment rail integration.

### Overview

The settlement lifecycle follows a three-phase model:

1. **Prepare**: Lock funds and create a settlement handle
2. **Commit**: Transfer locked funds from buyer to seller
3. **Abort**: Release locked funds back to buyer

All operations are **idempotent**: repeated calls with the same parameters return the same result without side effects.

### Types

```typescript
interface SettlementIntent {
  intent_id: string;           // Intent identifier
  from: string;                // Buyer agent ID
  to: string;                  // Seller agent ID
  amount: number;              // Amount to settle (>= 0)
  mode: "hash_reveal" | "streaming";  // Settlement mode
  meta?: Record<string, unknown>;      // Optional metadata
  idempotency_key?: string;    // Optional idempotency key for retries
}

interface SettlementHandle {
  handle_id: string;           // Deterministic handle ID
  intent_id: string;           // Intent identifier
  status: "prepared" | "committed" | "aborted";
  locked_amount: number;       // Amount locked in prepare
  created_at_ms: number;       // Creation timestamp
  meta?: Record<string, unknown>;  // Optional metadata
}

interface SettlementResult {
  ok: boolean;
  status: "prepared" | "committed" | "aborted";
  paid_amount: number;         // Amount actually paid
  handle_id: string;           // Settlement handle ID
  meta?: Record<string, unknown>;  // Optional metadata
}
```

### API Methods

#### `prepare(intent: SettlementIntent): Promise<SettlementHandle>`

Locks funds and creates a settlement handle.

**Behavior:**
- Validates funds (throws if insufficient balance)
- Locks amount from buyer's available balance
- Creates deterministic handle_id from `intent_id + idempotency_key` (SHA-256 hash)
- **Idempotent**: Repeated calls with same `(intent_id, idempotency_key)` return same handle

**Invariants:**
- `getBalance(from)` decreases by `amount`
- `getLocked(from)` increases by `amount`
- Handle status is `"prepared"`

**Example:**
```typescript
const intent: SettlementIntent = {
  intent_id: "intent-123",
  from: "buyer-pubkey",
  to: "seller-pubkey",
  amount: 0.1,
  mode: "hash_reveal",
  idempotency_key: "retry-abc", // Optional, for retry safety
};

const handle = await settlement.prepare(intent);
// handle.handle_id is deterministic based on intent_id + idempotency_key
// handle.status === "prepared"
```

#### `commit(handle_id: string): Promise<SettlementResult>`

Commits prepared settlement by transferring locked funds.

**Behavior:**
- Transfers locked funds from buyer to seller
- Updates handle status to `"committed"`
- **Idempotent**: Repeated calls return same result (no double-payment)

**Preconditions:**
- Handle must exist
- Handle status must be `"prepared"` (throws if `"committed"` or `"aborted"`)

**Invariants:**
- `getLocked(from)` decreases by `amount`
- `getBalance(to)` increases by `amount`
- Handle status changes from `"prepared"` to `"committed"`

**Example:**
```typescript
const result = await settlement.commit(handle.handle_id);
// result.status === "committed"
// result.paid_amount === 0.1

// Idempotent: safe to call multiple times
const result2 = await settlement.commit(handle.handle_id);
// result2 === result (same handle_id, same paid_amount)
```

#### `abort(handle_id: string, reason?: string): Promise<void>`

Aborts prepared settlement by releasing locked funds.

**Behavior:**
- Releases locked funds back to buyer's available balance
- Updates handle status to `"aborted"`
- **Idempotent**: Repeated calls succeed (safe to call multiple times)

**Preconditions:**
- Handle must exist
- Handle status must be `"prepared"` (throws if `"committed"`)

**Invariants:**
- `getLocked(from)` decreases by `amount`
- `getBalance(from)` increases by `amount`
- Handle status changes from `"prepared"` to `"aborted"`

**Example:**
```typescript
await settlement.abort(handle.handle_id, "Negotiation failed");

// Idempotent: safe to call multiple times
await settlement.abort(handle.handle_id); // No-op, already aborted
```

### Idempotency

All lifecycle operations are **idempotent** to enable safe retries:

- **`prepare()`**: Same `(intent_id, idempotency_key)` returns same handle (no double-locking)
- **`commit()`**: Same `handle_id` returns same result (no double-payment)
- **`abort()`**: Same `handle_id` succeeds (idempotent abort is safe)

**Handle ID Generation:**
- Deterministic: `SHA-256(intent_id + ":" + idempotency_key)`
- Encoded as base58 for shorter IDs
- Same inputs → same handle_id → same handle

**Example (Retry Safety):**
```typescript
// Network failure during prepare - safe to retry
let handle: SettlementHandle;
try {
  handle = await settlement.prepare(intent);
} catch (error) {
  // Retry (idempotent)
  handle = await settlement.prepare(intent); // Returns same handle if first succeeded
}

// Network failure during commit - safe to retry
try {
  await settlement.commit(handle.handle_id);
} catch (error) {
  // Retry (idempotent)
  await settlement.commit(handle.handle_id); // No double-payment
}
```

### Integration with Existing Code

The lifecycle API is **additive** and does not replace existing settlement methods:

- **Existing methods unchanged**: `lock()`, `pay()`, `release()`, `slashBond()`, etc.
- **Backward compatible**: All v1.5 demos work unchanged
- **MockSettlementProvider**: Implements lifecycle using existing methods internally

**Minimal Integration:**
- Exchange/engine code continues using existing settlement methods
- Lifecycle API is available but not required (opt-in)
- Future integration with external payment rails will use lifecycle API

### Implementation Status

- **MockSettlementProvider**: ✅ Full implementation with idempotency
- **ExternalSettlementProvider**: ✅ Stub implementation (throws `NotImplemented`)
- **Integration**: TODO (existing code unchanged, lifecycle available but not used)

### Testing

Comprehensive tests cover:
- ✅ Prepare idempotency (same handle for same inputs)
- ✅ Commit idempotency (no double-payment)
- ✅ Abort idempotency (safe repeated calls)
- ✅ State transitions (prepare → commit, prepare → abort)
- ✅ Error handling (insufficient balance, invalid states)
- ✅ Handle ID determinism (same inputs → same handle_id)

See `packages/sdk/src/settlement/__tests__/lifecycle.test.ts` for full test coverage.

### Backward Compatibility

All v1.5 guarantees remain unchanged:
- ✅ Existing settlement methods work identically
- ✅ Demos continue to work unchanged
- ✅ Protocol semantics unchanged (lifecycle is settlement-layer only)

**Additive changes only**: v1.6.1 adds optional lifecycle API without breaking v1.5 behavior.

---

## What's Next

Possible future enhancements (not in v1.6):

- **External payment rail integration**: Real implementations of `ExternalSettlementProvider` for Stripe, Ethereum, etc.
- **Async settlement**: Support for async operations (e.g., on-chain confirmation)
- **Settlement webhooks**: Callback support for external payment rails
- **Multi-signature settlement**: Support for governance-required settlements

These features may be considered for future versions but are explicitly **not** in v1.6.

